/*!
 * \file      lr1110-se.c
 *
 * \brief     LR1110 Secure Element hardware implementation
 *
 * \copyright Revised BSD License, see section \ref LICENSE.
 *
 * \code
 *                ______                              _
 *               / _____)             _              | |
 *              ( (____  _____ ____ _| |_ _____  ____| |__
 *               \____ \| ___ |    (_   _) ___ |/ ___)  _ \
 *               _____) ) ____| | | || |_| ____( (___| | | |
 *              (______/|_____)_|_|_| \__)_____)\____)_| |_|
 *              (C)2019-2019 Semtech
 *
 * \endcode
 *
 * \authors    Semtech WSP Applications Team
 */
#include <stdlib.h>
#include <stdint.h>

#include "lr1110.h"
#include "lr1110_system.h"
#include "lr1110_crypto_engine.h"

#include "secure-element.h"
#include "se-identity.h"
#include "lr1110-se-hal.h"

/*!
 * Number of supported crypto keys
 */
#define NUM_OF_KEYS 23

/*
 * CMAC/AES Message Integrity Code (MIC) Block B0 size
 */
#define MIC_BLOCK_BX_SIZE 16

/*
 * Maximum size of the message that can be handled by the crypto operations
 */
#define CRYPTO_MAXMESSAGE_SIZE 256

/*
 * Maximum size of the buffer for crypto operations
 */
#define CRYPTO_BUFFER_SIZE CRYPTO_MAXMESSAGE_SIZE + MIC_BLOCK_BX_SIZE

/*!
 * Size of JoinReqType is field for integrity check
 * \remark required for 1.1.x support
 */
#define JOIN_REQ_TYPE_SIZE 1

/*!
 * Size of DevNonce is field for integrity check
 * \remark required for 1.1.x support
 */
#define DEV_NONCE_SIZE 2

/*!
 * MIC computation offset
 * \remark required for 1.1.x support
 */
#define CRYPTO_MIC_COMPUTATION_OFFSET \
    ( JOIN_REQ_TYPE_SIZE + LORAMAC_JOIN_EUI_FIELD_SIZE + DEV_NONCE_SIZE + LORAMAC_MHDR_FIELD_SIZE )

/*!
 * Identifier value pair type for Keys
 */
typedef struct sKey
{
    /*
     * Key identifier
     */
    KeyIdentifier_t KeyID;
    /*
     * Key value
     */
    uint8_t KeyValue[SE_KEY_SIZE];
} Key_t;

/*!
 * Secure-element LoRaWAN identity local storage.
 */
typedef struct sSecureElementNvCtx
{
    /*
     * DevEUI storage
     */
    uint8_t DevEui[SE_EUI_SIZE];
    /*
     * Join EUI storage
     */
    uint8_t JoinEui[SE_EUI_SIZE];
    /*
     * PIN of the LR1110
     */
    uint8_t Pin[SE_PIN_SIZE];
#if !defined( SECURE_ELEMENT_PRE_PROVISIONED )
    /*
     * LoRaWAN key list
     */
    Key_t KeyList[NUM_OF_KEYS];
#endif
} SecureElementNvCtx_t;

static SecureElementNvCtx_t SeContext =
{
    /*!
     * end-device IEEE EUI (big endian)
     *
     * \remark In this application the value is automatically generated by calling
     *         BoardGetUniqueId function
     */
    .DevEui = LORAWAN_DEVICE_EUI,
    /*!
     * App/Join server IEEE EUI (big endian)
     */
    .JoinEui = LORAWAN_JOIN_EUI,
    /*!
     * Secure-element pin (big endian)
     */
    .Pin = SECURE_ELEMENT_PIN,
#if !defined( SECURE_ELEMENT_PRE_PROVISIONED )
    /*!
     * LoRaWAN key list
     */
    .KeyList = LR1110_SE_KEY_LIST
#endif
};

extern lr1110_t LR1110;

static lr1110_crypto_keys_idx_t convert_key_id_from_se_to_lr1110( KeyIdentifier_t key_id );

SecureElementStatus_t SecureElementInit( SecureElementNvmEvent seNvmCtxChanged )
{
    lr1110_crypto_status_t status = LR1110_CRYPTO_STATUS_ERROR;

    lr1110_crypto_restore_from_flash( &LR1110, &status );

#if defined( SECURE_ELEMENT_PRE_PROVISIONED )
    // Read LR1110 pre-provisioned identity
    lr1110_system_read_uid( &LR1110, SeContext.DevEui );
    lr1110_system_read_join_eui( &LR1110, SeContext.JoinEui );
    lr1110_system_read_pin( &LR1110, SeContext.Pin );
    // Store default LR1110 pre-provisioned identity
    SecureElementSetDevEui( SeContext.DevEui );
    SecureElementSetJoinEui( SeContext.JoinEui );
    SecureElementSetPin( SeContext.Pin );
#else
#if( STATIC_DEVICE_EUI == 0 )
    // Get a DevEUI from MCU unique ID
    LR1110SeHalGetUniqueId( SeContext.DevEui );
#endif
    SecureElementSetDevEui( SeContext.DevEui );
    SecureElementSetJoinEui( SeContext.JoinEui );
    SecureElementSetPin( SeContext.Pin );
    SecureElementSetKey( APP_KEY, SeContext.KeyList[APP_KEY].KeyValue );
    SecureElementSetKey( NWK_KEY, SeContext.KeyList[NWK_KEY].KeyValue );
    SecureElementSetKey( F_NWK_S_INT_KEY, SeContext.KeyList[F_NWK_S_INT_KEY].KeyValue );
    SecureElementSetKey( S_NWK_S_INT_KEY, SeContext.KeyList[S_NWK_S_INT_KEY].KeyValue );
    SecureElementSetKey( NWK_S_ENC_KEY, SeContext.KeyList[NWK_S_ENC_KEY].KeyValue );
    SecureElementSetKey( APP_S_KEY, SeContext.KeyList[APP_S_KEY].KeyValue );
    SecureElementSetKey( SLOT_RAND_ZERO_KEY, SeContext.KeyList[SLOT_RAND_ZERO_KEY].KeyValue );
#endif
    return ( SecureElementStatus_t ) status;
}

SecureElementStatus_t SecureElementRestoreNvmCtx( void* seNvmCtx )
{
    lr1110_crypto_status_t status = LR1110_CRYPTO_STATUS_ERROR;

    // Restore lr1110 crypto context
    lr1110_crypto_restore_from_flash( &LR1110, &status );
    return ( SecureElementStatus_t ) status;
}

void* SecureElementGetNvmCtx( size_t* seNvmCtxSize )
{
    *seNvmCtxSize = 0;
    return NULL;
}

SecureElementStatus_t SecureElementSetKey( KeyIdentifier_t keyID, uint8_t* key )
{
    if( key == NULL )
    {
        return SECURE_ELEMENT_ERROR_NPE;
    }

    SecureElementStatus_t status = SECURE_ELEMENT_ERROR;

    if( ( keyID == MC_KEY_0 ) || ( keyID == MC_KEY_1 ) || ( keyID == MC_KEY_2 ) || ( keyID == MC_KEY_3 ) )
    {  // Decrypt the key if its a Mckey

        lr1110_crypto_derive_and_store_key( &LR1110, ( lr1110_crypto_status_t* ) &status,
                                            convert_key_id_from_se_to_lr1110( MC_KE_KEY ),
                                            convert_key_id_from_se_to_lr1110( keyID ), key );

        if( status == SECURE_ELEMENT_SUCCESS )
        {
            lr1110_crypto_store_to_flash( &LR1110, ( lr1110_crypto_status_t* ) &status );
        }
        return status;
    }
    else
    {
        lr1110_crypto_set_key( &LR1110, ( lr1110_crypto_status_t* ) &status, convert_key_id_from_se_to_lr1110( keyID ),
                               key );
        if( status == SECURE_ELEMENT_SUCCESS )
        {
            lr1110_crypto_store_to_flash( &LR1110, ( lr1110_crypto_status_t* ) &status );
        }
        return status;
    }
}

SecureElementStatus_t SecureElementComputeAesCmac( uint8_t* micBxBuffer, uint8_t* buffer, uint16_t size,
                                                   KeyIdentifier_t keyID, uint32_t* cmac )
{
    SecureElementStatus_t status      = SECURE_ELEMENT_ERROR;
    uint16_t              localSize   = size;
    uint8_t*              localbuffer = buffer;

    if( micBxBuffer != NULL )
    {
        uint8_t micBuff[CRYPTO_BUFFER_SIZE];

        memset1( micBuff, 0, CRYPTO_BUFFER_SIZE );

        memcpy1( micBuff, micBxBuffer, MIC_BLOCK_BX_SIZE );
        memcpy1( ( micBuff + MIC_BLOCK_BX_SIZE ), buffer, size );
        localSize += MIC_BLOCK_BX_SIZE;
        localbuffer = micBuff;
    }

    lr1110_crypto_compute_aes_cmac( &LR1110, ( lr1110_crypto_status_t* ) &status,
                                    convert_key_id_from_se_to_lr1110( keyID ), localbuffer, localSize,
                                    ( uint8_t* ) cmac );

    return status;
}

SecureElementStatus_t SecureElementVerifyAesCmac( uint8_t* buffer, uint16_t size, uint32_t expectedCmac,
                                                  KeyIdentifier_t keyID )
{
    SecureElementStatus_t status = SECURE_ELEMENT_ERROR;

    if( buffer == NULL )
    {
        return SECURE_ELEMENT_ERROR_NPE;
    }

    lr1110_crypto_verify_aes_cmac( &LR1110, ( lr1110_crypto_status_t* ) &status,
                                   convert_key_id_from_se_to_lr1110( keyID ), buffer, size,
                                   ( uint8_t* ) &expectedCmac );

    return status;
}

SecureElementStatus_t SecureElementAesEncrypt( uint8_t* buffer, uint16_t size, KeyIdentifier_t keyID,
                                               uint8_t* encBuffer )
{
    SecureElementStatus_t status = SECURE_ELEMENT_ERROR;

    if( ( buffer == NULL ) || ( encBuffer == NULL ) )
    {
        return SECURE_ELEMENT_ERROR_NPE;
    }

    lr1110_crypto_aes_encrypt_01( &LR1110, ( lr1110_crypto_status_t* ) &status,
                                  convert_key_id_from_se_to_lr1110( keyID ), buffer, size, encBuffer );

    return status;
}

SecureElementStatus_t SecureElementDeriveAndStoreKey( Version_t version, uint8_t* input, KeyIdentifier_t rootKeyID,
                                                      KeyIdentifier_t targetKeyID )
{
    SecureElementStatus_t status = SECURE_ELEMENT_ERROR;

    if( input == NULL )
    {
        return SECURE_ELEMENT_ERROR_NPE;
    }

    lr1110_crypto_derive_and_store_key( &LR1110, ( lr1110_crypto_status_t* ) &status,
                                        convert_key_id_from_se_to_lr1110( rootKeyID ),
                                        convert_key_id_from_se_to_lr1110( targetKeyID ), input );

    lr1110_crypto_store_to_flash( &LR1110, ( lr1110_crypto_status_t* ) &status );
    return status;
}

SecureElementStatus_t SecureElementProcessJoinAccept( JoinReqIdentifier_t joinReqType, uint8_t* joinEui,
                                                      uint16_t devNonce, uint8_t* encJoinAccept,
                                                      uint8_t encJoinAcceptSize, uint8_t* decJoinAccept,
                                                      uint8_t* versionMinor )
{
    SecureElementStatus_t status = SECURE_ELEMENT_ERROR;

    if( ( encJoinAccept == NULL ) || ( decJoinAccept == NULL ) || ( versionMinor == NULL ) )
    {
        return SECURE_ELEMENT_ERROR_NPE;
    }

    // Determine decryption key
    KeyIdentifier_t encKeyID = NWK_KEY;

    if( joinReqType != JOIN_REQ )
    {
        encKeyID = J_S_ENC_KEY;
    }

    //  - Header buffer to be used for MIC computation
    //        - LoRaWAN 1.0.x : micHeader = [MHDR(1)]
    //        - LoRaWAN 1.1.x : micHeader = [JoinReqType(1), JoinEUI(8), DevNonce(2), MHDR(1)]

    // Try first to process LoRaWAN 1.0.x JoinAccept
    uint8_t micHeader10[1] = { 0x20 };

    //   cmac = aes128_cmac(NwkKey, MHDR |  JoinNonce | NetID | DevAddr | DLSettings | RxDelay | CFList |
    //   CFListType)
    lr1110_crypto_process_join_accept(
        &LR1110, ( lr1110_crypto_status_t* ) &status, convert_key_id_from_se_to_lr1110( encKeyID ),
        convert_key_id_from_se_to_lr1110( NWK_KEY ), ( lr1110_crypto_lorawan_version_t ) 0, micHeader10,
        encJoinAccept + 1, encJoinAcceptSize - 1, decJoinAccept + 1 );

    if( status != SECURE_ELEMENT_SUCCESS )
    {  // Then try to process LoRaWAN 1.1.x and later JoinAccept
        uint8_t  micHeader11[CRYPTO_MIC_COMPUTATION_OFFSET] = { 0 };
        uint16_t bufItr                                     = 0;

        //   cmac = aes128_cmac(JSIntKey, JoinReqType | JoinEUI | DevNonce | MHDR | JoinNonce | NetID | DevAddr |
        //   DLSettings | RxDelay | CFList | CFListType)
        micHeader11[bufItr++] = ( uint8_t ) joinReqType;

        memcpyr( micHeader11 + bufItr, joinEui, LORAMAC_JOIN_EUI_FIELD_SIZE );
        bufItr += LORAMAC_JOIN_EUI_FIELD_SIZE;

        micHeader11[bufItr++] = devNonce & 0xFF;
        micHeader11[bufItr++] = ( devNonce >> 8 ) & 0xFF;

        micHeader11[bufItr++] = 0x20;

        lr1110_crypto_process_join_accept(
            &LR1110, ( lr1110_crypto_status_t* ) &status, convert_key_id_from_se_to_lr1110( encKeyID ),
            convert_key_id_from_se_to_lr1110( J_S_INT_KEY ), ( lr1110_crypto_lorawan_version_t ) 1, micHeader11,
            encJoinAccept + 1, encJoinAcceptSize - 1, decJoinAccept + 1 );
    }
    *versionMinor = ( ( decJoinAccept[11] & 0x80 ) == 0x80 ) ? 1 : 0;
    return status;
}

SecureElementStatus_t SecureElementRandomNumber( uint32_t* randomNum )
{
    if( randomNum == NULL )
    {
        return SECURE_ELEMENT_ERROR_NPE;
    }
    *randomNum = LR1110SeHalGetRandomNumber( );
    return SECURE_ELEMENT_SUCCESS;
}

SecureElementStatus_t SecureElementSetDevEui( uint8_t* devEui )
{
    SecureElementStatus_t status = SECURE_ELEMENT_ERROR;

    if( devEui == NULL )
    {
        return SECURE_ELEMENT_ERROR_NPE;
    }

    memcpy1( SeContext.DevEui, devEui, SE_EUI_SIZE );

    lr1110_crypto_set_parameter( &LR1110, ( lr1110_crypto_status_t* ) &status, 0, devEui );
    lr1110_crypto_set_parameter( &LR1110, ( lr1110_crypto_status_t* ) &status, 1, devEui + 4 );
    lr1110_crypto_store_to_flash( &LR1110, ( lr1110_crypto_status_t* ) &status );

    return status;
}

uint8_t* SecureElementGetDevEui( void )
{
    SecureElementStatus_t status = SECURE_ELEMENT_ERROR;

    lr1110_crypto_get_parameter( &LR1110, ( lr1110_crypto_status_t* ) &status, 0, SeContext.DevEui );
    lr1110_crypto_get_parameter( &LR1110, ( lr1110_crypto_status_t* ) &status, 1, SeContext.DevEui + 4 );

    return SeContext.DevEui;
}

SecureElementStatus_t SecureElementSetJoinEui( uint8_t* joinEui )
{
    SecureElementStatus_t status = SECURE_ELEMENT_ERROR;

    if( joinEui == NULL )
    {
        return SECURE_ELEMENT_ERROR_NPE;
    }

    memcpy1( SeContext.JoinEui, joinEui, SE_EUI_SIZE );

    lr1110_crypto_set_parameter( &LR1110, ( lr1110_crypto_status_t* ) &status, 2, joinEui );
    lr1110_crypto_set_parameter( &LR1110, ( lr1110_crypto_status_t* ) &status, 3, joinEui + 4 );

    lr1110_crypto_store_to_flash( &LR1110, ( lr1110_crypto_status_t* ) &status );

    return status;
}

uint8_t* SecureElementGetJoinEui( void )
{
    SecureElementStatus_t status = SECURE_ELEMENT_ERROR;

    lr1110_crypto_get_parameter( &LR1110, ( lr1110_crypto_status_t* ) &status, 2, SeContext.JoinEui );
    lr1110_crypto_get_parameter( &LR1110, ( lr1110_crypto_status_t* ) &status, 3, SeContext.JoinEui + 4 );

    return SeContext.JoinEui;
}

SecureElementStatus_t SecureElementSetPin( uint8_t* pin )
{
    SecureElementStatus_t status = SECURE_ELEMENT_ERROR;

    if( pin == NULL )
    {
        return SECURE_ELEMENT_ERROR_NPE;
    }

    memcpy1( SeContext.Pin, pin, SE_PIN_SIZE );

    lr1110_crypto_set_parameter( &LR1110, ( lr1110_crypto_status_t* ) &status, 4, pin );

    lr1110_crypto_store_to_flash( &LR1110, ( lr1110_crypto_status_t* ) &status );

    return status;
}

uint8_t* SecureElementGetPin( void )
{
    SecureElementStatus_t status = SECURE_ELEMENT_ERROR;

    lr1110_crypto_get_parameter( &LR1110, ( lr1110_crypto_status_t* ) &status, 4, SeContext.Pin );

    return SeContext.Pin;
}

static lr1110_crypto_keys_idx_t convert_key_id_from_se_to_lr1110( KeyIdentifier_t key_id )
{
    lr1110_crypto_keys_idx_t id = LR1110_CRYPTO_KEYS_IDX_GP0;

    switch( key_id )
    {
    case APP_KEY:
        id = LR1110_CRYPTO_KEYS_IDX_APP_KEY;
        break;
    case NWK_KEY:
        id = LR1110_CRYPTO_KEYS_IDX_NWK_KEY;
        break;
    case J_S_INT_KEY:
        id = LR1110_CRYPTO_KEYS_IDX_J_S_INT_KEY;
        break;
    case J_S_ENC_KEY:
        id = LR1110_CRYPTO_KEYS_IDX_J_S_ENC_KEY;
        break;
    case F_NWK_S_INT_KEY:
        id = LR1110_CRYPTO_KEYS_IDX_F_NWK_S_INT_KEY;
        break;
    case S_NWK_S_INT_KEY:
        id = LR1110_CRYPTO_KEYS_IDX_S_NWK_S_INT_KEY;
        break;
    case NWK_S_ENC_KEY:
        id = LR1110_CRYPTO_KEYS_IDX_NWK_S_ENC_KEY;
        break;
    case APP_S_KEY:
        id = LR1110_CRYPTO_KEYS_IDX_APP_S_KEY;
        break;
    case MC_ROOT_KEY:
        id = LR1110_CRYPTO_KEYS_IDX_GP_KE_KEY_5;
        break;
    case MC_KE_KEY:
        id = LR1110_CRYPTO_KEYS_IDX_GP_KE_KEY_4;
        break;
    case MC_KEY_0:
        id = LR1110_CRYPTO_KEYS_IDX_GP_KE_KEY_0;
        break;
    case MC_APP_S_KEY_0:
        id = LR1110_CRYPTO_KEYS_IDX_MC_APP_S_KEY_0;
        break;
    case MC_NWK_S_KEY_0:
        id = LR1110_CRYPTO_KEYS_IDX_MC_NWK_S_KEY_0;
        break;
    case MC_KEY_1:
        id = LR1110_CRYPTO_KEYS_IDX_GP_KE_KEY_1;
        break;
    case MC_APP_S_KEY_1:
        id = LR1110_CRYPTO_KEYS_IDX_MC_APP_S_KEY_1;
        break;
    case MC_NWK_S_KEY_1:
        id = LR1110_CRYPTO_KEYS_IDX_MC_NWK_S_KEY_1;
        break;
    case MC_KEY_2:
        id = LR1110_CRYPTO_KEYS_IDX_GP_KE_KEY_2;
        break;
    case MC_APP_S_KEY_2:
        id = LR1110_CRYPTO_KEYS_IDX_MC_APP_S_KEY_2;
        break;
    case MC_NWK_S_KEY_2:
        id = LR1110_CRYPTO_KEYS_IDX_MC_NWK_S_KEY_2;
        break;
    case MC_KEY_3:
        id = LR1110_CRYPTO_KEYS_IDX_GP_KE_KEY_3;
        break;
    case MC_APP_S_KEY_3:
        id = LR1110_CRYPTO_KEYS_IDX_MC_APP_S_KEY_3;
        break;
    case MC_NWK_S_KEY_3:
        id = LR1110_CRYPTO_KEYS_IDX_MC_NWK_S_KEY_3;
        break;
    case SLOT_RAND_ZERO_KEY:
        id = LR1110_CRYPTO_KEYS_IDX_GP0;
        break;
    default:
        id = LR1110_CRYPTO_KEYS_IDX_GP1;
        break;
    }
    return id;
}
